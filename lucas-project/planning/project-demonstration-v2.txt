Bemutató:

Mit lehetne bemutatni?

=========
Frontend:
1. Login oldal bemutatása => Többet erről itt (Springboot/2. pont)



2. Milyen további oldalak jöhetnek?
	2.1. Bejelentés oldal
		- Amennyiben a felhasználó valamilyen hibát talál, vagy hibát tapasztal, avagy nem tetszik neki valami az oldallal kapcsolatban, avagy nehezen tudja értelmezni az oldal és a szűrési felület működését, akkor bejelentéseket tehetnek.
		- Lehessen kiválasztani a bejelentés témáját: ["Bug", "UI Bug", "Others"]
		- Amennyiben egy felhasználó elküld egy ilyen bejelentést, akkor az eltárolásra kerülhetne az adatbázisban.
			- Továbbá azt, hogy ki küldte
			- Azt, hogy megvalósításra/fixálásra került-e
			- Azt, hogy mikor küldték be
			- A bejelentés tartalma
		- Amennyiben bejelentéseket tesznek a felhasználók, azokról a fejlesztő (azaz én) kapjon azonnali visszajelzést, email formájában.
			- A saját, privát email címemre kerüljön egy üzenet elküldés a bejelentés legfontosabb adataival.
			- Miért jó ez így? Mivel, amennyiben nem dolgozom a projekten aktívan, akkor a bejelentéseket sem fogom aktívan nézni. Amennyiben email-ben kapok üzenetet (amit napi szinten nézek), akkor biztos fogok is arra reagálni valamit.
		- [Fejlesztőnek]: 
			- Az email küldést meg lehet valósítani mind a frontend és a backend oldaláról (legyen inkább a backend)
			- Az email címéből lehessen kiolvasni, hogy ki küldte, és mi a problémája az alkalmazással.


	2.2. Manual
		- Legyen egy Manual oldal, ahol az alkalmazás működésével kapcsolatos legfontosabb információkat meg lehet találni (pl. információ a szűrési oldal működéséről, említést tenni a Bejelentés oldalról)


	2.3. Settings
		- Itt lehet beállítani, hogy a lokális/távoli képeket használjuk.















3. Szűrési oldal
	- Bemutatni a szűrési oldalt
	- Bemutatni a logikát, hogy hogyan lehet a jövőben az egyes szűrési opciókat egymás után láncba fűzni.
		- Ki tudod jelölni, hogy a "country" / "year" / "coordinate" alapján szűrsz.
		- Ki tudod tölteni az űrlapot és elmenteni azt.
		- Az így elmentett űrlap adatai feltöltésre kerülnek egy táblába -> hozzáadásra kerülnek a DEFAULT group-hoz.
		- Egy group-on belüli komponensek mindegyikére össze lehet fűzni AND/OR logikai kifejezésekkel. 

			pl. Group1 
				2009-ben készült kép
				<< ÉS >>
				56 <= X koordinátán készült kép
				<< ÉS >>
				X <= 90 koordinátán készült kép (ezzel definiálhatunk egy intervallumot az X koordinátának)
				<< ÉS >>
				PROCEDURE_NAME_AA eljárás került a képeken futtatásra
				<< ÉS >>
				PLANT_TYPA_AA növénytípus detektálásra került a képen

			Group1 rövide:
				- (év:2009 =) ÉS (x:56 <=) ÉS (x:90 >=) ÉS (procedure:PROCEDURE_NAME_AA =) ÉS (type:PLANT_TYPE_AA !=)

			Group2 rövide:
				- (év:2009 =) ÉS (x:56 <=) ÉS (x:90 >=) ÉS (procedure:PROCEDURE_NAME_BB =) ÉS (type:PLANT_TYPE_BB !=)

				- Mit jelent a (type:PLANT_TYPE_BB !=)
					- PLANT_TYPA_BB növénytípus NEM került detektálásra a képen

			Definiáljunk egy relációt az egyes csoportok között:
				- Group1 << ÉS >> Group2

					- Azon képeket tartalmazza, amik 2009-es évben készültek, az x koordinátája [56, 90] között van, és az első eljárással megtalálta az A típusú növényt, MIKÖZBEN ugyan ezen évben, ugyanezen x koordinátán a második eljárás NEM találta meg a B típusú növényt.

			Definiáljunk relációkat TÖBB csoport között:
				- Legyenek a csoportjaink: GROUPS={ group1, group2, group3, group4, group5, group6 }

				- Relációk a csoportok között:
					- (group1 << OR >> group2) << AND >> ( group3 << OR >> group4 << OR >> group5 ) << AND >> group6

				- Bonyolúltnak tűnik? Írjuk fel egyszerűbben:
					- group1-2 << AND >> group3-4-5 << AND >> group6



===========
Springboot:
1. Flyway migration
	- Létrehozza számomra az adatbázisban lévő egyes táblákat és a köztük lévő kapcsolatokat.
	- Miér hasznos? 
		- Amennyiben kint van production környezetben az alkalmazás és az adatbázis, akkor csak úgy babrálni az adatbázissal veszélyes és nem tanácsos. Innen backend oldalról tudjuk frissíteni az adatbázis tábláit, sorait, beszúrni új táblákat, új kapcsolatokat felvenni, és módosítani az adatokat.
	- Ezzel dinamikusan lehet módosítani az adatbázisban lévő adatokat.
	- [Fejlesztőnek]
		- Link a cikkez, amit fel kell dolgozni: https://medium.com/twodigits/flyway-an-introduction-and-best-practices-14f10aa7498c



2. Emailek titkosítása
	- Minden google email titkosításra kerül a backend oldalán, és kerülnek hash-elt változatban elmentésre az adatbázisban.

	- AES256-os titkosítás került implementálásra
		- Várja az input szöveget
		- Egy 512 karakter hosszú szöveget fűz az input szöveg után, ami egy random generált szöveg azon célból, hogy az input szöveg (amit titkosítani akarunk) az sokkal hosszabb legyen, és lassabban lehessen feltörni azt brute force-al.
		- Egy 256 karakter hosszú privát titkos kulcscsal titkosítsuk a szövegeket.



3. Google Auth Token Validation
	- Amikor a felhasznál bejelentkezik a login oldalon, akkor a Google visszaad egy auth token-t, ami minden esetben elküldésre kerül a frontend oldalról a backend oldalra. Itt leellenőrizzük, hogy a bejelentkezett felhasználó email címe az benne van-e az adatbázisban, illetve azt, hogy a token expired állapotú vagy sem (illetve azt, hogy jött-e token a frontend oldalról).

	- Ezzel az egyes backend oldalakat authentikációhoz kötjük, ami miatt korlátozzuk, hogy mi férhessen hozzá a backend-hez, nem is beszélve az adatbázisban lévő adatokhoz.



4. Dto
	- Amikor lekérdezünk adatokat a táblákból, akkor akár az egész tábla struktúráját is vissza adhatjuk egy http response-ban, ami esélyt ad arra, hogy a kliens oldalán rálátást kapjanak arra, hogy az egyes táblák hogyan épülnek fel.

	- Nem is beszélve arról, hogy bizonyos adatokat (szenzitív adatokat) nem akarunk visszaadni a felhasználóknak, így ezen lekért adatokat cast-oljuk egy dto objektumra, majd azokat adjuk vissza (a dto ugyan azon attribútumokat tárolja, mint az entity, csak kevesebb attribútummal).



5. JPA Pagination
	- (Még nincs ez teljesen megvalósítva!)

	- Page, PageableResponse 
		- Célja, hogy visszaadjon egy oldalt, amin a megjelenítendő adatok vannak
		- Lapozás/Pagination: Kérjük le a következő/előző 10 rekordot az adatbázisból.

	- Miért jó ez a megoldás?
		- Mivel ha van egy 1000 vagy 1'000'000 rekordunk, akkor azt egyben ne adjuk vissza a backend-ről, mivel a válaszidő az örökkévalósákig is tarthat. Amennyiben nagyon gyorsan indítunk több ilyen lekérdezést, akkor a request-ek lassulása már nagyon látványos lehet.
		- PageResponse használatával CSAK 10/fix számú rekordot adunk vissza. A válaszidő nagyon gyors lesz a kis méretű rekordok száma vissza (amit visszaadunk a frontend-nek).

	- Milyen adatokat tárolunk el a request-ben?
		- pageNumber
		- pageSize
		- pageOrder (ASC, DESC)

	- Milyen adatokat tárolunk el a response-ban?
		- pageNumber
		- pageSize
		- pageOrder
		- items<T>[] (tetszőleges típusú objektum többel térjen vissza)

	-> Dto használata
		- Amikor visszaadjuk az adatokat, akkor a TableEntity átkonvertálásra kerül TableDto-ra, ahol is elrejtjük az egyes adattagjait az objektumnak, és úgy adjuk vissza a frontend-nek.



6. CriteriaBuilder + Comparator
	- Dinamikus SQL lekérdezések létrehozása.
	- Olyen lekérdezések írása, amihez NEM kell nyers SQL utasításokat írnunk, helyette programozzuk azokat.
	- Objektum-orientált kontroll a lekérdezések írása felett.
		- pl. objektumok összehasonlítása
		- Amennyiben össze akarunk hasonlítani objektumokat, akkor csak az objektumokat nem tudunk összehasonlítani. -> Ehhez vannak a Comparator-ok. Minden egyes osztályban megmondhatjuk, hogy milyen adattípusok alapján kerüljenek az azonos típusú objektumok összehasonlításra.
		- Miért kell ez nekünk? Mi van, ha akarok egy olyan lekérdezést, hogy (year == 2009, coordinate_x >= 58, stb.). 

	- Csináltam egy ősosztályt BaseComparatorEntity néven. Ebben van definiálva egy abstract comparTo metódus, amiben minden gyermek osztályben felül kell definiálni. Ha felül vannak definiálva, akkor az ős típust felhasználva, tudunk objektum-orientált módon összehasonlításokat végezni a táblákon.



7. SoftDeletable
	- pl. Amennyiben törlünk egy felhasználót, akkor az adott felhasználóhoz tartozó rekordok törlésre kerülnének, így inkább megtartjuk az adatbázisban a rekordot, csak jelezzük egy "deletedAt" és "deletedBy" attribútumokkal, hogy ki törölte és mikor törölte az adott rekordot.

	- Van egy olyan annotáció, hogy @Where, amivel megtilthatjuk, hogy lekérdezésre kerüljenek azon rekordok CSAK a felhasználó táblából, akiknek a "deletedAt" értéke NEM null. Ez nincs kihatással a többi táblára, tehát képesek leszünk lekérdezni más táblák adatait, miközben azok hivatkoznak a felhasználó tábla egyes rekordjaira.



8. TableEntity
	- Olyan osztály, ami definiál egy adott táblának a szerkezetét (kulcs, külső kulcs)	
	- Öröklődések:
		TableEntity >> SoftDeletableEntity >> AuditedEntity >> BaseEntity >> BaseComparatorEntity
		TableEntity >> AuditedEntity >> BaseEntity >> BaseComparatorEntity
		TableEntity >> BaseEntity >> BaseComparatorEntity
		TableEntity >> BaseComparatorEntity



9. ErrorHandling
	- BaseException extends RuntimeException
	- ImageFilterException extends BaseException

	- Miért jó?
		- Amennyiben hiba kerül dobásra az alkalmazásban, akkor arról szeretnénk figyelmeztetni a felhasználót a frontend-en, illetve a fejlesztőt is.
		- Ha egy RuntimeException-t dobunk, akkor egy hibaüzenetet adhatunk vissza a felhasználónak, egy előre definiált http státusz kóddal.
		- Legyen egy olyan eset, amikor a BaseException-ből származó hibákat kapjuk el. Ezen esetben adjunk vissza egy egyedi hibaüzenetet a felhasználónak, a hiba okáról, és a hiba státuszkódját.
		- Legyen egy olyan eset, amikor az összes többi hibát kapjuk el. Ilyenkor Internal-Server-Error kerüljön visszaadásra a felhasználónak.



Mi várható még?
- Tranzakció kezelés (Transaction Management)
	- Biztos lesz olyan eset, amikor versenyhelyzet alakul ki. Emiatt a backend-et fel kell készíteni arra, hogy az egyes táblákat zárolhassuk.
	- SpringBoot-ban vannak beépített annitációk, amik segítenek pontosan ezt megvalósítani (márcsak tudni kell használni őket).
	- Táblák kerüljenek zárolásra, ahol lehetséges versenyhelyzet kialakulhat.

- UtilClass
	- Egy olyan osztály, amit több osztályban fel lehet használni (pl. számok átalakítása más típusra, időpont vagy idő kezelése).
	- Ezen osztályokat NEM lehet példányosítani, ha példányosítjuk, akkor hiba fog dobásra kerülni
	- Minden metódus az osztályon belül elérhetjük statikusan. (pl. CLASS_NAME_AAA.METHOD_NAME_AAA)



==========
Adatbázis:



1. CoordinateX és CoordinateY táblák létrehozása
	- Létrehozni külön táblákat, amik eltárolják azon coordináta értékeket, ahol az egyes képek elkészültek. Ezek alapból el vannak tárolva a tb_image táblában, de ennek köszönhetően, sokkal gyorsabban tudjuk kinyerni az egyes koordináta értékeket, és szűrni általuk a képekre.



2. Plant-PlantName-PlantSpecies specializáló kapcsolat
	- Létrehozni az adatbázisban ezen specializáló kapcsolatból leképezett sémák mindegyikét.
	- Rájöttem, hogy egy tudományos névvel ellátott növénynek több common_name-je lehet, ami miatt többértékű attribútummá tettem a common_name-t a PlantName egyedben.



3. Procedure, ProcedureLogs, BoundingBox táblák
	- Létrehozni ezen táblákat az adatbázisban


=======
Docker
- docker-compose.yml fájlban definiálni lehet egy adatbázis image-et, amit lehúzhatunk a docker hub-ból.
- A docker-ben konténerek csatlakozni tudnak ezen adatbázishoz. Lehetséges az adatbázist is létrehozni docker-compose-al. Ezt követően a backend-el fel lehet tölteni az adatbázist a táblákkal és különböző relációkkal.
- Kényelmes, mivel a docker elintézi mindezt, és a fejlesztőnek nem kell külön foglalkoznia az adatbázis bekonfigurálásával.



======
Demonstrátori munka!